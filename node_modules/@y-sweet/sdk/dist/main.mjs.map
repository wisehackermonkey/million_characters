{"version":3,"sources":["../src/main.ts"],"sourcesContent":["/**\n * Schema of object returned after a successful document creation.\n */\nexport type DocCreationResult = {\n  /** A unique identifier for the created document. */\n  docId: string\n}\n\n/**\n * An object containing information needed for the client connect to a document.\n *\n * This value is expected to be passed from your server to your client. Your server\n * should obtain this value by calling {@link DocumentManager.getClientToken},\n * and then pass it to the client.\n */\nexport type ClientToken = {\n  /** The bare URL of the WebSocket endpoint to connect to. The `doc` string will be appended to this. */\n  url: string\n\n  /** A unique identifier for the document that the token connects to. */\n  docId: string\n\n  /** A string that grants the bearer access to the document. By default, the development server does not require a token. */\n  token?: string\n}\n\nfunction generateRandomString(): string {\n  return Math.random().toString(36).substring(2)\n}\n\n/** Metadata associated with a {@link YSweetError}. */\nexport type YSweetErrorPayload =\n  | { code: 'ServerRefused'; address: string; port: number; url: string }\n  | { code: 'ServerError'; status: number; message: string; url: string }\n  | { code: 'NoAuthProvided' }\n  | { code: 'InvalidAuthProvided' }\n  | { code: 'Unknown'; message: string }\n\nexport type CheckStoreResult = { ok: true } | { ok: false; error: string }\n\n/** An error returned by the y-sweet SDK. */\nexport class YSweetError extends Error {\n  /**\n   * Create a new {@link YSweetError}.\n   *\n   * @param cause An object representing metadata associated with the error.\n   * @see {@link YSweetErrorPayload}\n   */\n  constructor(public cause: YSweetErrorPayload) {\n    super(YSweetError.getMessage(cause))\n    this.name = 'YSweetError'\n  }\n\n  /** Convert the message to an error string that can be displayed to the user.\n   *\n   * The error string can also be used with {@link YSweetError.fromMessage} to\n   * reconstruct the payload object, which is useful in the context of Next.js,\n   * which will only pass an error string from the server to the client.\n   *\n   * @param payload The payload object to convert to a string.\n   * @returns A string representation of the error.\n   */\n  static getMessage(payload: YSweetErrorPayload): string {\n    let message\n    if (payload.code === 'ServerRefused') {\n      message = `Server at ${payload.address}:${payload.port} refused connection. URL: ${payload.url}`\n    } else if (payload.code === 'ServerError') {\n      message = `Server responded with ${payload.status} ${payload.message}. URL: ${payload.url}`\n    } else if (payload.code === 'NoAuthProvided') {\n      message = 'No auth provided'\n    } else if (payload.code === 'InvalidAuthProvided') {\n      message = 'Invalid auth provided'\n    } else {\n      message = payload.message\n    }\n    return `${payload.code}: ${message}`\n  }\n\n  /**\n   * In development, next.js passes error objects to the client but strips out everything but the\n   * `message` field. This method allows us to reconstruct the original error object.\n   *\n   * @param messageString The error message string to reconstruct a payload from.\n   * @returns A {@link YSweetError} object.\n   * @see {@link https://nextjs.org/docs/app/api-reference/file-conventions/error#errormessage| Next.js docs}\n   */\n  static fromMessage(messageString: string): YSweetError {\n    let match = messageString.match(/^(.*?): (.*)$/)\n    if (!match) {\n      return new YSweetError({ code: 'Unknown', message: messageString })\n    }\n\n    let [, code, message] = match\n\n    if (code === 'ServerRefused') {\n      match = message.match(/^Server at (.*?):(\\d+) refused connection. URL: (.*)$/)\n      if (!match) {\n        return new YSweetError({ code: 'Unknown', message: messageString })\n      }\n\n      let [, address, port, url] = match\n      return new YSweetError({ code, address, port: parseInt(port), url })\n    }\n\n    if (code === 'ServerError') {\n      match = message.match(/^Server responded with (\\d+) (.*). URL: (.*)$/)\n      if (!match) {\n        return new YSweetError({ code: 'Unknown', message: messageString })\n      }\n\n      let [, status, statusText, url] = match\n      return new YSweetError({ code, status: parseInt(status), message: statusText, url })\n    }\n\n    if (code === 'NoAuthProvided') {\n      return new YSweetError({ code })\n    }\n\n    if (code === 'InvalidAuthProvided') {\n      return new YSweetError({ code })\n    }\n\n    return new YSweetError({ code: 'Unknown', message })\n  }\n}\n\n/** Represents an interface to a y-sweet document management endpoint. */\nexport class DocumentManager {\n  /** The base URL of the remote document manager API. */\n  private baseUrl: string\n\n  /** A string that grants the bearer access to the document management API. */\n  private token?: string\n\n  /**\n   * Create a new {@link DocumentManager}.\n   *\n   * @param serverToken A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n   */\n  constructor(connectionString: string) {\n    const parsedUrl = new URL(connectionString)\n\n    let token\n    if (parsedUrl.username) {\n      // Decode the token from the URL.\n      token = decodeURIComponent(parsedUrl.username)\n    }\n\n    let protocol = parsedUrl.protocol\n    if (protocol === 'ys:') {\n      protocol = 'http:'\n    } else if (protocol === 'yss:') {\n      protocol = 'https:'\n    }\n\n    // NB: we manually construct the string here because node's URL implementation does\n    //     not handle changing the protocol of a URL well.\n    //     see: https://nodejs.org/api/url.html#urlprotocol\n    const url = `${protocol}//${parsedUrl.host}${parsedUrl.pathname}${parsedUrl.search}`\n\n    this.baseUrl = url.replace(/\\/$/, '')\n    this.token = token\n  }\n\n  private async doFetch(url: string, method: 'GET'): Promise<Response>\n  private async doFetch(url: string, method: 'POST', body: Record<string, any>): Promise<Response>\n\n  /** Internal helper for making an authorized fetch request to the API.  */\n  private async doFetch(\n    url: string,\n    method: 'GET' | 'POST',\n    body?: Record<string, any>,\n  ): Promise<Response> {\n    let headers: [string, string][] = []\n    if (this.token) {\n      // Tokens come base64 encoded.\n      headers.push(['Authorization', `Bearer ${this.token}`])\n    }\n\n    let bodyJson\n    if (method === 'POST') {\n      headers.push(['Content-Type', 'application/json'])\n      bodyJson = JSON.stringify(body)\n    }\n\n    let result: Response\n\n    // NOTE: In some environments (e.g. NextJS), responses are cached by default. Disabling\n    // the cache using `cache: 'no-store'` causes fetch() to error in other environments\n    // (e.g. Cloudflare Workers). To work around this, we simply add a cache-busting query\n    // param.\n    const cacheBust = generateRandomString()\n    url = `${this.baseUrl}/${url}?z=${cacheBust}`\n    try {\n      result = await fetch(url, {\n        method,\n        body: bodyJson,\n        headers,\n      })\n    } catch (error: any) {\n      if (error.cause?.code === 'ECONNREFUSED') {\n        let { address, port } = error.cause\n        throw new YSweetError({ code: 'ServerRefused', address, port, url })\n      } else {\n        throw new YSweetError({ code: 'Unknown', message: error.toString() })\n      }\n    }\n\n    if (!result.ok) {\n      if (result.status === 401) {\n        if (this.token) {\n          throw new YSweetError({ code: 'InvalidAuthProvided' })\n        } else {\n          throw new YSweetError({ code: 'NoAuthProvided' })\n        }\n      }\n\n      throw new YSweetError({\n        code: 'ServerError',\n        status: result.status,\n        message: result.statusText,\n        url,\n      })\n    }\n\n    return result\n  }\n\n  public async checkStore(): Promise<CheckStoreResult> {\n    return await (await this.doFetch('check_store', 'GET')).json()\n  }\n\n  /**\n   * Creates a new document on the y-sweet server given an optional docId. If a document with given\n   * ID already exists, this is a no-op.\n   *\n   * @param docId The ID of the document to be created. If not provided, a random ID will be generated.\n   * @returns A {@link DocCreationResult} object containing the ID of the created document.\n   */\n  public async createDoc(docId?: string): Promise<DocCreationResult> {\n    const body = docId ? { docId } : {}\n    const result = await this.doFetch('doc/new', 'POST', body)\n    if (!result.ok) {\n      throw new Error(`Failed to create doc: ${result.status} ${result.statusText}`)\n    }\n    const responseBody = (await result.json()) as DocCreationResult\n    return responseBody\n  }\n\n  /**\n   * Get a client token for the given document.\n   *\n   * If you are using authorization, this is expected to be called from your server\n   * after a user has authenticated. The returned token should then be passed to the\n   * client.\n   *\n   * @param docId The ID of the document to get a token for.\n   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n   */\n  public async getClientToken(docId: string | DocCreationResult): Promise<ClientToken> {\n    if (typeof docId !== 'string') {\n      docId = docId.docId\n    }\n\n    const result = await this.doFetch(`doc/${docId}/auth`, 'POST', {})\n    if (!result.ok) {\n      throw new Error(`Failed to auth doc ${docId}: ${result.status} ${result.statusText}`)\n    }\n    const responseBody = (await result.json()) as ClientToken\n    return responseBody\n  }\n\n  /**\n   * A convenience wrapper around {@link DocumentManager.createDoc} and {@link DocumentManager.getClientToken} for\n   * getting a client token for a document. If a docId is provided, ensures that a document exists with that ID or\n   * that one is created. If no docId is provided, a new document is created with a random ID.\n   *\n   * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.\n   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n   */\n  public async getOrCreateDocAndToken(docId?: string): Promise<ClientToken> {\n    const result = await this.createDoc(docId)\n    return await this.getClientToken(result)\n  }\n\n  /**\n   * Returns an entire document, represented as a Yjs update byte string.\n   *\n   * This can be turned back into a Yjs document as follows:\n   *\n   * ```typescript\n   * import * as Y from 'yjs'\n   *\n   * let update = await manager.getDocAsUpdate(docId)\n   * let doc = new Y.Doc()\n   * doc.transact(() => {\n   *  Y.applyUpdate(doc, update)\n   * })\n   * ```\n   *\n   * @param docId\n   * @returns\n   */\n  public async getDocAsUpdate(docId: string): Promise<Uint8Array> {\n    const result = await this.doFetch(`doc/${docId}/as-update`, 'GET')\n    if (!result.ok) {\n      throw new Error(`Failed to get doc ${docId}: ${result.status} ${result.statusText}`)\n    }\n\n    let buffer = await result.arrayBuffer()\n    return new Uint8Array(buffer)\n  }\n\n  /**\n   * Updates a document with the given Yjs update byte string.\n   *\n   * This can be generated from a Yjs document as follows:\n   *\n   * ```typescript\n   * import * as Y from 'yjs'\n   *\n   * let doc = new Y.Doc()\n   * // Modify the document...\n   * let update = Y.encodeStateAsUpdate(doc)\n   * await manager.updateDoc(docId, update)\n   * ```\n   *\n   * @param docId\n   * @param update\n   */\n  public async updateDoc(docId: string, update: Uint8Array): Promise<void> {\n    let headers: [string, string][] = [['Content-Type', 'application/octet-stream']]\n    if (this.token) {\n      headers.push(['Authorization', `Bearer ${this.token}`])\n    }\n\n    const result = await fetch(`${this.baseUrl}/doc/${docId}/update`, {\n      method: 'POST',\n      body: update,\n      headers,\n    })\n\n    if (!result.ok) {\n      throw new Error(`Failed to update doc ${docId}: ${result.status} ${result.statusText}`)\n    }\n  }\n}\n\n/**\n * A convenience wrapper around {@link DocumentManager.getOrCreateDocAndToken} for getting or creating a document\n * with the given ID and returning a client token for accessing it.\n *\n * @param connectionString A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.\n * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n */\nexport async function getOrCreateDocAndToken(\n  connectionString: string,\n  docId?: string,\n): Promise<ClientToken> {\n  const manager = new DocumentManager(connectionString)\n  return await manager.getOrCreateDocAndToken(docId)\n}\n\n/**\n * A convenience wrapper around {@link DocumentManager.getClientToken} for getting a client token for a document.\n *\n * @param connectionString A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n * @param docId The ID of the document to get a token for.\n * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n */\nexport async function getClientToken(\n  connectionString: string,\n  docId: string | DocCreationResult,\n): Promise<ClientToken> {\n  const manager = new DocumentManager(connectionString)\n  return await manager.getClientToken(docId)\n}\n\n/**\n * A convenience wrapper around {@link DocumentManager.createDoc} for creating a new document. If a document with the\n * given ID already exists, this is a no-op.\n *\n * @param connectionString A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n * @param docId The ID of the document to create. If not provided, a random ID will be generated.\n * @returns A {@link DocCreationResult} object containing the ID of the created document.\n */\nexport async function createDoc(\n  connectionString: string,\n  docId?: string,\n): Promise<DocCreationResult> {\n  const manager = new DocumentManager(connectionString)\n  return await manager.createDoc(docId)\n}\n\nfunction stringToBase64(input: string) {\n  if (typeof window !== 'undefined' && window.btoa) {\n    // Browser\n    return window.btoa(input)\n  } else if (typeof Buffer !== 'undefined') {\n    // Node.js\n    return Buffer.from(input).toString('base64')\n  } else {\n    throw new Error('Unable to encode to Base64')\n  }\n}\n\nfunction base64ToString(input: string) {\n  if (typeof window !== 'undefined' && window.atob) {\n    // Browser\n    return window.atob(input)\n  } else if (typeof Buffer !== 'undefined') {\n    // Node.js\n    return Buffer.from(input, 'base64').toString()\n  } else {\n    throw new Error('Unable to decode from Base64')\n  }\n}\n\nexport function encodeClientToken(token: ClientToken): string {\n  const jsonString = JSON.stringify(token)\n  let base64 = stringToBase64(jsonString)\n  base64 = base64.replace('+', '-').replace('/', '_').replace(/=+$/, '')\n  return base64\n}\n\nexport function decodeClientToken(token: string): ClientToken {\n  let base64 = token.replace('-', '+').replace('_', '/')\n  while (base64.length % 4) {\n    base64 += '='\n  }\n  const jsonString = base64ToString(base64)\n  return JSON.parse(jsonString)\n}\n"],"mappings":"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","names":[]}