/**
 * Schema of object returned after a successful document creation.
 */
type DocCreationResult = {
    /** A unique identifier for the created document. */
    docId: string;
};
/**
 * An object containing information needed for the client connect to a document.
 *
 * This value is expected to be passed from your server to your client. Your server
 * should obtain this value by calling {@link DocumentManager.getClientToken},
 * and then pass it to the client.
 */
type ClientToken = {
    /** The bare URL of the WebSocket endpoint to connect to. The `doc` string will be appended to this. */
    url: string;
    /** A unique identifier for the document that the token connects to. */
    docId: string;
    /** A string that grants the bearer access to the document. By default, the development server does not require a token. */
    token?: string;
};
/** Metadata associated with a {@link YSweetError}. */
type YSweetErrorPayload = {
    code: 'ServerRefused';
    address: string;
    port: number;
    url: string;
} | {
    code: 'ServerError';
    status: number;
    message: string;
    url: string;
} | {
    code: 'NoAuthProvided';
} | {
    code: 'InvalidAuthProvided';
} | {
    code: 'Unknown';
    message: string;
};
type CheckStoreResult = {
    ok: true;
} | {
    ok: false;
    error: string;
};
/** An error returned by the y-sweet SDK. */
declare class YSweetError extends Error {
    cause: YSweetErrorPayload;
    /**
     * Create a new {@link YSweetError}.
     *
     * @param cause An object representing metadata associated with the error.
     * @see {@link YSweetErrorPayload}
     */
    constructor(cause: YSweetErrorPayload);
    /** Convert the message to an error string that can be displayed to the user.
     *
     * The error string can also be used with {@link YSweetError.fromMessage} to
     * reconstruct the payload object, which is useful in the context of Next.js,
     * which will only pass an error string from the server to the client.
     *
     * @param payload The payload object to convert to a string.
     * @returns A string representation of the error.
     */
    static getMessage(payload: YSweetErrorPayload): string;
    /**
     * In development, next.js passes error objects to the client but strips out everything but the
     * `message` field. This method allows us to reconstruct the original error object.
     *
     * @param messageString The error message string to reconstruct a payload from.
     * @returns A {@link YSweetError} object.
     * @see {@link https://nextjs.org/docs/app/api-reference/file-conventions/error#errormessage| Next.js docs}
     */
    static fromMessage(messageString: string): YSweetError;
}
/** Represents an interface to a y-sweet document management endpoint. */
declare class DocumentManager {
    /** The base URL of the remote document manager API. */
    private baseUrl;
    /** A string that grants the bearer access to the document management API. */
    private token?;
    /**
     * Create a new {@link DocumentManager}.
     *
     * @param serverToken A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.
     */
    constructor(connectionString: string);
    private doFetch;
    checkStore(): Promise<CheckStoreResult>;
    /**
     * Creates a new document on the y-sweet server given an optional docId. If a document with given
     * ID already exists, this is a no-op.
     *
     * @param docId The ID of the document to be created. If not provided, a random ID will be generated.
     * @returns A {@link DocCreationResult} object containing the ID of the created document.
     */
    createDoc(docId?: string): Promise<DocCreationResult>;
    /**
     * Get a client token for the given document.
     *
     * If you are using authorization, this is expected to be called from your server
     * after a user has authenticated. The returned token should then be passed to the
     * client.
     *
     * @param docId The ID of the document to get a token for.
     * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
     */
    getClientToken(docId: string | DocCreationResult): Promise<ClientToken>;
    /**
     * A convenience wrapper around {@link DocumentManager.createDoc} and {@link DocumentManager.getClientToken} for
     * getting a client token for a document. If a docId is provided, ensures that a document exists with that ID or
     * that one is created. If no docId is provided, a new document is created with a random ID.
     *
     * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.
     * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
     */
    getOrCreateDocAndToken(docId?: string): Promise<ClientToken>;
    /**
     * Returns an entire document, represented as a Yjs update byte string.
     *
     * This can be turned back into a Yjs document as follows:
     *
     * ```typescript
     * import * as Y from 'yjs'
     *
     * let update = await manager.getDocAsUpdate(docId)
     * let doc = new Y.Doc()
     * doc.transact(() => {
     *  Y.applyUpdate(doc, update)
     * })
     * ```
     *
     * @param docId
     * @returns
     */
    getDocAsUpdate(docId: string): Promise<Uint8Array>;
    /**
     * Updates a document with the given Yjs update byte string.
     *
     * This can be generated from a Yjs document as follows:
     *
     * ```typescript
     * import * as Y from 'yjs'
     *
     * let doc = new Y.Doc()
     * // Modify the document...
     * let update = Y.encodeStateAsUpdate(doc)
     * await manager.updateDoc(docId, update)
     * ```
     *
     * @param docId
     * @param update
     */
    updateDoc(docId: string, update: Uint8Array): Promise<void>;
}
/**
 * A convenience wrapper around {@link DocumentManager.getOrCreateDocAndToken} for getting or creating a document
 * with the given ID and returning a client token for accessing it.
 *
 * @param connectionString A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.
 * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.
 * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
 */
declare function getOrCreateDocAndToken(connectionString: string, docId?: string): Promise<ClientToken>;
/**
 * A convenience wrapper around {@link DocumentManager.getClientToken} for getting a client token for a document.
 *
 * @param connectionString A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.
 * @param docId The ID of the document to get a token for.
 * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
 */
declare function getClientToken(connectionString: string, docId: string | DocCreationResult): Promise<ClientToken>;
/**
 * A convenience wrapper around {@link DocumentManager.createDoc} for creating a new document. If a document with the
 * given ID already exists, this is a no-op.
 *
 * @param connectionString A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.
 * @param docId The ID of the document to create. If not provided, a random ID will be generated.
 * @returns A {@link DocCreationResult} object containing the ID of the created document.
 */
declare function createDoc(connectionString: string, docId?: string): Promise<DocCreationResult>;
declare function encodeClientToken(token: ClientToken): string;
declare function decodeClientToken(token: string): ClientToken;

export { CheckStoreResult, ClientToken, DocCreationResult, DocumentManager, YSweetError, YSweetErrorPayload, createDoc, decodeClientToken, encodeClientToken, getClientToken, getOrCreateDocAndToken };
