// src/main.ts
function generateRandomString() {
  return Math.random().toString(36).substring(2);
}
var YSweetError = class _YSweetError extends Error {
  /**
   * Create a new {@link YSweetError}.
   *
   * @param cause An object representing metadata associated with the error.
   * @see {@link YSweetErrorPayload}
   */
  constructor(cause) {
    super(_YSweetError.getMessage(cause));
    this.cause = cause;
    this.name = "YSweetError";
  }
  /** Convert the message to an error string that can be displayed to the user.
   *
   * The error string can also be used with {@link YSweetError.fromMessage} to
   * reconstruct the payload object, which is useful in the context of Next.js,
   * which will only pass an error string from the server to the client.
   *
   * @param payload The payload object to convert to a string.
   * @returns A string representation of the error.
   */
  static getMessage(payload) {
    let message;
    if (payload.code === "ServerRefused") {
      message = `Server at ${payload.address}:${payload.port} refused connection. URL: ${payload.url}`;
    } else if (payload.code === "ServerError") {
      message = `Server responded with ${payload.status} ${payload.message}. URL: ${payload.url}`;
    } else if (payload.code === "NoAuthProvided") {
      message = "No auth provided";
    } else if (payload.code === "InvalidAuthProvided") {
      message = "Invalid auth provided";
    } else {
      message = payload.message;
    }
    return `${payload.code}: ${message}`;
  }
  /**
   * In development, next.js passes error objects to the client but strips out everything but the
   * `message` field. This method allows us to reconstruct the original error object.
   *
   * @param messageString The error message string to reconstruct a payload from.
   * @returns A {@link YSweetError} object.
   * @see {@link https://nextjs.org/docs/app/api-reference/file-conventions/error#errormessage| Next.js docs}
   */
  static fromMessage(messageString) {
    let match = messageString.match(/^(.*?): (.*)$/);
    if (!match) {
      return new _YSweetError({ code: "Unknown", message: messageString });
    }
    let [, code, message] = match;
    if (code === "ServerRefused") {
      match = message.match(/^Server at (.*?):(\d+) refused connection. URL: (.*)$/);
      if (!match) {
        return new _YSweetError({ code: "Unknown", message: messageString });
      }
      let [, address, port, url] = match;
      return new _YSweetError({ code, address, port: parseInt(port), url });
    }
    if (code === "ServerError") {
      match = message.match(/^Server responded with (\d+) (.*). URL: (.*)$/);
      if (!match) {
        return new _YSweetError({ code: "Unknown", message: messageString });
      }
      let [, status, statusText, url] = match;
      return new _YSweetError({ code, status: parseInt(status), message: statusText, url });
    }
    if (code === "NoAuthProvided") {
      return new _YSweetError({ code });
    }
    if (code === "InvalidAuthProvided") {
      return new _YSweetError({ code });
    }
    return new _YSweetError({ code: "Unknown", message });
  }
};
var DocumentManager = class {
  /**
   * Create a new {@link DocumentManager}.
   *
   * @param serverToken A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.
   */
  constructor(connectionString) {
    const parsedUrl = new URL(connectionString);
    let token;
    if (parsedUrl.username) {
      token = decodeURIComponent(parsedUrl.username);
    }
    let protocol = parsedUrl.protocol;
    if (protocol === "ys:") {
      protocol = "http:";
    } else if (protocol === "yss:") {
      protocol = "https:";
    }
    const url = `${protocol}//${parsedUrl.host}${parsedUrl.pathname}${parsedUrl.search}`;
    this.baseUrl = url.replace(/\/$/, "");
    this.token = token;
  }
  /** Internal helper for making an authorized fetch request to the API.  */
  async doFetch(url, method, body) {
    let headers = [];
    if (this.token) {
      headers.push(["Authorization", `Bearer ${this.token}`]);
    }
    let bodyJson;
    if (method === "POST") {
      headers.push(["Content-Type", "application/json"]);
      bodyJson = JSON.stringify(body);
    }
    let result;
    const cacheBust = generateRandomString();
    url = `${this.baseUrl}/${url}?z=${cacheBust}`;
    try {
      result = await fetch(url, {
        method,
        body: bodyJson,
        headers
      });
    } catch (error) {
      if (error.cause?.code === "ECONNREFUSED") {
        let { address, port } = error.cause;
        throw new YSweetError({ code: "ServerRefused", address, port, url });
      } else {
        throw new YSweetError({ code: "Unknown", message: error.toString() });
      }
    }
    if (!result.ok) {
      if (result.status === 401) {
        if (this.token) {
          throw new YSweetError({ code: "InvalidAuthProvided" });
        } else {
          throw new YSweetError({ code: "NoAuthProvided" });
        }
      }
      throw new YSweetError({
        code: "ServerError",
        status: result.status,
        message: result.statusText,
        url
      });
    }
    return result;
  }
  async checkStore() {
    return await (await this.doFetch("check_store", "GET")).json();
  }
  /**
   * Creates a new document on the y-sweet server given an optional docId. If a document with given
   * ID already exists, this is a no-op.
   *
   * @param docId The ID of the document to be created. If not provided, a random ID will be generated.
   * @returns A {@link DocCreationResult} object containing the ID of the created document.
   */
  async createDoc(docId) {
    const body = docId ? { docId } : {};
    const result = await this.doFetch("doc/new", "POST", body);
    if (!result.ok) {
      throw new Error(`Failed to create doc: ${result.status} ${result.statusText}`);
    }
    const responseBody = await result.json();
    return responseBody;
  }
  /**
   * Get a client token for the given document.
   *
   * If you are using authorization, this is expected to be called from your server
   * after a user has authenticated. The returned token should then be passed to the
   * client.
   *
   * @param docId The ID of the document to get a token for.
   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
   */
  async getClientToken(docId) {
    if (typeof docId !== "string") {
      docId = docId.docId;
    }
    const result = await this.doFetch(`doc/${docId}/auth`, "POST", {});
    if (!result.ok) {
      throw new Error(`Failed to auth doc ${docId}: ${result.status} ${result.statusText}`);
    }
    const responseBody = await result.json();
    return responseBody;
  }
  /**
   * A convenience wrapper around {@link DocumentManager.createDoc} and {@link DocumentManager.getClientToken} for
   * getting a client token for a document. If a docId is provided, ensures that a document exists with that ID or
   * that one is created. If no docId is provided, a new document is created with a random ID.
   *
   * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.
   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
   */
  async getOrCreateDocAndToken(docId) {
    const result = await this.createDoc(docId);
    return await this.getClientToken(result);
  }
  /**
   * Returns an entire document, represented as a Yjs update byte string.
   *
   * This can be turned back into a Yjs document as follows:
   *
   * ```typescript
   * import * as Y from 'yjs'
   *
   * let update = await manager.getDocAsUpdate(docId)
   * let doc = new Y.Doc()
   * doc.transact(() => {
   *  Y.applyUpdate(doc, update)
   * })
   * ```
   *
   * @param docId
   * @returns
   */
  async getDocAsUpdate(docId) {
    const result = await this.doFetch(`doc/${docId}/as-update`, "GET");
    if (!result.ok) {
      throw new Error(`Failed to get doc ${docId}: ${result.status} ${result.statusText}`);
    }
    let buffer = await result.arrayBuffer();
    return new Uint8Array(buffer);
  }
  /**
   * Updates a document with the given Yjs update byte string.
   *
   * This can be generated from a Yjs document as follows:
   *
   * ```typescript
   * import * as Y from 'yjs'
   *
   * let doc = new Y.Doc()
   * // Modify the document...
   * let update = Y.encodeStateAsUpdate(doc)
   * await manager.updateDoc(docId, update)
   * ```
   *
   * @param docId
   * @param update
   */
  async updateDoc(docId, update) {
    let headers = [["Content-Type", "application/octet-stream"]];
    if (this.token) {
      headers.push(["Authorization", `Bearer ${this.token}`]);
    }
    const result = await fetch(`${this.baseUrl}/doc/${docId}/update`, {
      method: "POST",
      body: update,
      headers
    });
    if (!result.ok) {
      throw new Error(`Failed to update doc ${docId}: ${result.status} ${result.statusText}`);
    }
  }
};
async function getOrCreateDocAndToken(connectionString, docId) {
  const manager = new DocumentManager(connectionString);
  return await manager.getOrCreateDocAndToken(docId);
}
async function getClientToken(connectionString, docId) {
  const manager = new DocumentManager(connectionString);
  return await manager.getClientToken(docId);
}
async function createDoc(connectionString, docId) {
  const manager = new DocumentManager(connectionString);
  return await manager.createDoc(docId);
}
function stringToBase64(input) {
  if (typeof window !== "undefined" && window.btoa) {
    return window.btoa(input);
  } else if (typeof Buffer !== "undefined") {
    return Buffer.from(input).toString("base64");
  } else {
    throw new Error("Unable to encode to Base64");
  }
}
function base64ToString(input) {
  if (typeof window !== "undefined" && window.atob) {
    return window.atob(input);
  } else if (typeof Buffer !== "undefined") {
    return Buffer.from(input, "base64").toString();
  } else {
    throw new Error("Unable to decode from Base64");
  }
}
function encodeClientToken(token) {
  const jsonString = JSON.stringify(token);
  let base64 = stringToBase64(jsonString);
  base64 = base64.replace("+", "-").replace("/", "_").replace(/=+$/, "");
  return base64;
}
function decodeClientToken(token) {
  let base64 = token.replace("-", "+").replace("_", "/");
  while (base64.length % 4) {
    base64 += "=";
  }
  const jsonString = base64ToString(base64);
  return JSON.parse(jsonString);
}
export {
  DocumentManager,
  YSweetError,
  createDoc,
  decodeClientToken,
  encodeClientToken,
  getClientToken,
  getOrCreateDocAndToken
};
//# sourceMappingURL=main.mjs.map