import * as Y from 'yjs';
import * as encoding from 'lib0/encoding';
import * as decoding from 'lib0/decoding';
import * as awarenessProtocol from 'y-protocols/awareness';
import { Observable } from 'lib0/observable';
import { ClientToken } from '@y-sweet/sdk';

/**
 * Adapted from y-websocket
 *
 * https://raw.githubusercontent.com/yjs/y-websocket/master/src/y-websocket.js
 */

type HandlerFunction = (encoder: encoding.Encoder, decoder: decoding.Decoder, provider: YSweetProvider, emitSynced: boolean, messageType: number) => void;
type WebSocketPolyfillType = {
    new (url: string | URL, protocols?: string | string[] | undefined): WebSocket;
    prototype: WebSocket;
    readonly CLOSED: number;
    readonly CLOSING: number;
    readonly CONNECTING: number;
    readonly OPEN: number;
};
type YSweetProviderParams = {
    connect?: boolean;
    awareness?: awarenessProtocol.Awareness;
    params?: {
        [x: string]: string;
    };
    WebSocketPolyfill?: WebSocketPolyfillType;
    resyncInterval?: number;
    maxBackoffTime?: number;
    disableBc?: boolean;
};
/**
 * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.
 * The document name is attached to the provided url. I.e. the following example
 * creates a websocket connection to http://localhost:1234/my-document-name
 *
 * @example
 * import * as Y from 'yjs'
 * import { YSweetProvider } from 'y-websocket'
 * const doc = new Y.Doc()
 * const provider = new YSweetProvider('http://localhost:1234', 'my-document-name', doc)
 * @extends {Observable<string>}
 */
declare class YSweetProvider extends Observable<string> {
    maxBackoffTime: number;
    bcChannel: string;
    url: string;
    roomname: string;
    doc: Y.Doc;
    _WS: WebSocketPolyfillType;
    awareness: awarenessProtocol.Awareness;
    wsconnected: boolean;
    wsconnecting: boolean;
    bcconnected: boolean;
    disableBc: boolean;
    wsUnsuccessfulReconnects: number;
    messageHandlers: Array<HandlerFunction>;
    _synced: boolean;
    ws: WebSocket | null;
    wsLastMessageReceived: number;
    shouldConnect: boolean;
    _resyncInterval: ReturnType<typeof setInterval> | number;
    _bcSubscriber: Function;
    _updateHandler: (arg0: Uint8Array, arg1: any, arg2: Y.Doc, arg3: Y.Transaction) => void;
    _awarenessUpdateHandler: Function;
    _unloadHandler: Function;
    _checkInterval: ReturnType<typeof setInterval> | number;
    /**
     * @param serverUrl - server url
     * @param roomname - room name
     * @param doc - Y.Doc instance
     * @param opts - options
     * @param opts.connect - connect option
     * @param opts.awareness - awareness protocol instance
     * @param opts.params - parameters
     * @param opts.WebSocketPolyfill - WebSocket polyfill
     * @param opts.resyncInterval - resync interval
     * @param opts.maxBackoffTime - maximum backoff time
     * @param opts.disableBc - disable broadcast channel
     */
    constructor(serverUrl: string, roomname: string, doc: Y.Doc, { connect, awareness, params, WebSocketPolyfill, resyncInterval, maxBackoffTime, disableBc, }?: YSweetProviderParams);
    /**
     * @type {boolean}
     */
    get synced(): boolean;
    set synced(state: boolean);
    destroy(): void;
    connectBc(): void;
    disconnectBc(): void;
    disconnect(): void;
    connect(): void;
}

/**
 * Given a {@link ClientToken}, create a {@link YSweetProvider} for it.
 *
 * @param doc
 * @param clientToken
 * @param extraOptions
 * @returns
 */
declare function createYjsProvider(doc: Y.Doc, clientToken: ClientToken, extraOptions?: Partial<YSweetProviderParams>): YSweetProvider;
/**
 * Get a URL to open the Y-Sweet Debugger for the given client token.
 *
 * @param clientToken The client token to open the debugger for.
 * @returns A debugger URL as a string.
 */
declare function debuggerUrl(clientToken: ClientToken): string;

export { YSweetProvider, YSweetProviderParams, createYjsProvider, debuggerUrl };
